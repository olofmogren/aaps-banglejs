// === GLOBAL DATA and CONSTANTS
// ===================================================================================
const MGDL_TO_MMOL = 18.0182;
const HIGH_MMOL = 10.0;
const LOW_MMOL = 4.0;
const H = g.getHeight();
const W = g.getWidth();
let drawTimeout;

// === GLOBAL DATA and CONSTANTS ===
let currentBgData = { sgv: "---", trend: "FLAT", ts: 0 };
let currentStatusData = { iob: "---", cob: "---", ts: 0 };
let historyData = { glucose: [], treatments: [] };
let clockInterval; // To keep track of the main clock timer

// === DATA HANDLING AND DRAWING ===

// ** OPTIMIZED: This function ONLY reads the lightweight files. **
function updateCurrentData() {
  let needsRedraw = false;

  const bgFile = require("Storage").readJSON("aaps_bg.json", 1);
  if (bgFile && bgFile.ts > currentBgData.ts) {
    currentBgData = bgFile;
    needsRedraw = true;
  }

  const statusFile = require("Storage").readJSON("aaps_status.json", 1);
  if (statusFile && statusFile.ts > currentStatusData.ts) {
    currentStatusData = statusFile;
    needsRedraw = true;
  }

  // We only redraw if something new was loaded and the screen is on.
  if (needsRedraw && Bangle.isLCDOn()) {
    draw();
  }
}

// ** NEW: This is the HEAVY function that ONLY runs when needed. **
function assembleHistoryAndDraw() {
  console.log("Assembling full history...");
  const metaFile = require("Storage").readJSON("aaps_h_meta.json", 1);
  if (metaFile) {
    let assembledGlucose = [];
    for (let i = 0; i < metaFile.glucoseChunks; i++) {
      let chunkFile = require("Storage").readJSON(`aaps_h_gl_${i}.json`, 1);
      if (chunkFile && chunkFile.glucose) {
        assembledGlucose = assembledGlucose.concat(chunkFile.glucose);
      }
    }
    // (You would do the same for treatments here)

    const sortByTimestamp = (a, b) => a.ts - b.ts;
    historyData.glucose = assembledGlucose
    //.sort(sortByTimestamp);
    // historyData.treatments = ...
  }

  // After the heavy lifting is done, trigger a final redraw.
  if (Bangle.isLCDOn()) {
    draw();
  }
}

// === MASTER DRAW FUNCTION ===
// This function is now very fast because it doesn't read any files.
function draw() {
  // --- This is the new, reliable way to keep the time updated ---
  if (clockInterval) clearInterval(clockInterval);
  clockInterval = setTimeout(() => {
    if (Bangle.isLCDOn()) draw();
  }, 60000 - (Date.now() % 60000));
  // ---

  g.reset();
  g.clear();
  Bangle.loadWidgets();
  Bangle.drawWidgets();

  const leftCol = { x: 0, y: 24, w: 72, h: H - 24 };
  const topRight = { x: leftCol.w + 1, y: 24, w: W - leftCol.w - 1, h: 80 };
  const bottomRight = { x: leftCol.w + 1, y: topRight.y + topRight.h, w: W - leftCol.w - 1, h: H - topRight.y - topRight.h };

  drawLeftColumn(leftCol.x, leftCol.y, leftCol.w, leftCol.h);
  drawTopRight(topRight.x, topRight.y, topRight.w, topRight.h);
  drawBottomRightGraph(bottomRight.x, bottomRight.y, bottomRight.w, bottomRight.h);
}

function drawLeftColumn(x, y, w, h) {
  let glucoseMmol = null, deltaMmol = null;
  let textColor = "#000";

  glucoseMmol = currentBgData.sgv / MGDL_TO_MMOL;

  if (glucoseMmol >= HIGH_MMOL || glucoseMmol <= LOW_MMOL) textColor = "#F00"; // Red if out of range

  const sgvText = currentBgData.sgv ? glucoseMmol.toFixed(1) : "---";
  const mainBgX = x + w / 2;
  const mainBgY = y + 20;

  // --- Calculate the age of the reading ---
  let minutesAgo = 100; // Default if no data
  // Check if we have a valid timestamp
  if (currentBgData.ts > 0) {
    // Difference in milliseconds
    let timeDiff = Date.now() - currentBgData.ts;
    // Convert to minutes and round to the nearest whole number
    minutesAgo = Math.round(timeDiff / 60000);
  }

  if (minutesAgo > 5) {
    let textColor = "#999";
  }
  
  g.setFontAlign(0, 0);
  g.setColor(textColor).setFont("Vector", 32).drawString(sgvText, mainBgX, mainBgY);
  
  if (minutesAgo > 1) {
    // Get the width of the BG text to position the superscript correctly
    const sgvTextWidth = g.stringWidth(currentBgData.sgv);
    
    // Calculate position: to the right of the main text, and raised up
    const superscriptX = mainBgX + (sgvTextWidth / 2) + 3; // 3px gap
    const superscriptY = mainBgY - 10; // 10px higher than the main text's center

    g.setFontAlign(-1, 0); // Left-align the superscript
    g.setFont("6x8", 1.5); // Use a small but readable font
    g.drawString(`(${minutesAgo})`, superscriptX, superscriptY);
  }
  
  const latestEntry = historyData.glucose[0];
  let fiveMinOldEntry = null;
  if (historyData.glucose.length > 1) {
    const latestTime = new Date(latestEntry.ts).getTime();
    for (let i = 1; i < historyData.glucose.length; i++) {
      if (latestTime - new Date(historyData.glucose[i].ts).getTime() >= 270000) {
        fiveMinOldEntry = historyData.glucose[i];
        break;
      }
    }
  }
  if (fiveMinOldEntry) {
    deltaMmol = glucoseMmol - (fiveMinOldEntry.sgv / MGDL_TO_MMOL);
    g.setColor("#000"); 
    const deltaString = (deltaMmol >= 0 ? "+" : "") + deltaMmol.toFixed(1);
    g.setFont("6x8", 2).drawString(deltaString, x + w/2 - 10, y + 48);
  }
  else {
    g.setFont("6x8", 2).drawString("dnf", x + w/2 - 10, y + 48);
  }
  g.setColor("#000"); 
  drawTrendArrow(x + w/2 + 25, y + 48, currentBgData.trend);

  g.setFont("6x8", 2).setFontAlign(0, 0);
  g.drawString(currentStatusData.cob, x + w/2, y + h/2 + 15);
  g.drawString(currentStatusData.iob, x + w/2, y + h - 20);
  
  g.setColor("#F00"); // Red separator line
  g.fillRect(x + w -1, y, x + w, y + h);
}

function drawTrendArrow(x, y, type) {
  g.setColor("#000");
  const ARROW_SIZE = 8;
  if (!type) return;
  switch (type) {
    case "FLAT": g.fillPoly([x-ARROW_SIZE,y, x,y-ARROW_SIZE/2, x,y+ARROW_SIZE/2, x-ARROW_SIZE,y]); g.fillRect(x-ARROW_SIZE,y-1,x,y+1); break;
    case "FORTY_FIVE_UP": g.fillPoly([x-ARROW_SIZE,y+ARROW_SIZE, x+ARROW_SIZE,y-ARROW_SIZE, x,y-ARROW_SIZE, x-ARROW_SIZE,y]); break;
    case "FORTY_FIVE_DOWN": g.fillPoly([x-ARROW_SIZE,y-ARROW_SIZE, x+ARROW_SIZE,y+ARROW_SIZE, x,y+ARROW_SIZE, x-ARROW_SIZE,y]); break;
    case "UP": g.fillPoly([x,y-ARROW_SIZE, x-ARROW_SIZE/2,y, x+ARROW_SIZE/2,y, x,y-ARROW_SIZE]); g.fillRect(x-1,y,x+1,y+ARROW_SIZE); break;
    case "DOWN": g.fillPoly([x,y+ARROW_SIZE, x-ARROW_SIZE/2,y, x+ARROW_SIZE/2,y, x,y+ARROW_SIZE]); g.fillRect(x-1,y-ARROW_SIZE,x+1,y); break;
    default: ;
  }
}

function drawTopRight(x, y, w, h) {
  g.setColor(0,0,0);
  const d = new Date();
  const timeYPos = y + 2;
  let hStr = ("0"+d.getHours()).substr(-2), mStr = ("0"+d.getMinutes()).substr(-2);
  g.setFont("Vector", 42); 
  const hWidth = g.stringWidth(hStr);
  g.setFont("Vector", 30);
  const mWidth = g.stringWidth(mStr);
  const gap = 2, totalWidth = hWidth + gap + mWidth, horizontalShift = 4;
  let currentX = x + (w - totalWidth) / 2 + horizontalShift;
  g.setFont("Vector", 42).setFontAlign(-1, -1);
  g.drawString(hStr, currentX, timeYPos);
  currentX += hWidth + gap;
  g.setFont("Vector", 30).setFontAlign(-1, -1); 
  g.drawString(mStr, currentX, timeYPos);
  const dateYPos = timeYPos + 46;
  const locale = require("locale");
  const day = locale.dow(d, 1).toUpperCase(), date = d.getDate(), month = locale.month(d, 1).toUpperCase();
  g.setFont("Vector", 15).setFontAlign(0, 0);
  g.drawString(`${day} ${date} ${month}`, x + w/2, dateYPos);
}

function drawBottomRightGraph(x, y, w, h) {
  const margin = 5;
  const graphX = x + margin;
  const graphW = w - (margin * 2);
  const MIN_MMOL_SCALE = 2.0;
  const MAX_MMOL_SCALE = 14.0;
  let threshColor = g.getBgColor() == "#ffffff" ? [0.8,0,0] : [0,0,0];
  g.setColor.apply(g, threshColor);
  let highY = y + h - (((HIGH_MMOL - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
  let lowY = y + h - (((LOW_MMOL - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
  g.drawLine(graphX, highY, graphX + graphW, highY);
  g.drawLine(graphX, lowY, graphX + graphW, lowY);

  let now = new Date().getTime();
  let twoHoursAgo = now - (2 * 60 * 60 * 1000);

  g.setColor(0,0,0);
  //if (historyData.glucose && historyData.glucose.length >= 2) {
  //  for (let i = 0; i < historyData.glucose.length; i++) {
  //      let p1 = historyData.glucose[i];
  //      if (!p1) continue;
  //      let p1_mmol = p1.sgv / MGDL_TO_MMOL;
  //      let x = graphX + graphW * (new Date(p1.ts).getTime() - twoHoursAgo) / (2 * 60 * 60 * 1000);
  //      let y = y + h - (((p1_mmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
  //      g.drawLine(x-1, y-1, x+1, y-1);
  //      g.drawLine(x-1, y, x+1, y);
  //      g.drawLine(x-1, y+1, x+1, y+1);
  //  }
  //}
  if (historyData.glucose && historyData.glucose.length >= 2) {
    for (let i = 0; i < historyData.glucose.length - 1; i++) {
        let p1 = historyData.glucose[i], p2 = historyData.glucose[i+1];
        if (!p1 || !p2) continue;
        let p1_mmol = p1.sgv / MGDL_TO_MMOL, p2_mmol = p2.sgv / MGDL_TO_MMOL;
        let x1 = graphX + graphW * (new Date(p1.ts).getTime() - twoHoursAgo) / (2 * 60 * 60 * 1000);
        let x2 = graphX + graphW * (new Date(p2.ts).getTime() - twoHoursAgo) / (2 * 60 * 60 * 1000);
        let y1 = y + h - (((p1_mmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
        let y2 = y + h - (((p2_mmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
        if (x1 >= graphX && x2 <= graphX+graphW) {
          g.drawLine(x1, y1, x2, y2);
          g.drawLine(x1, y1+1, x2, y2+1);
          g.drawLine(x1, y1+2, x2, y2+2);
        }
    }
  }
  
  historyData.treatments.forEach(t => {
      let start = new Date(t.ts).getTime();
      //if (t.eventType === "Temp Basal" && t.absolute !== undefined) {
      //    g.setColor(0, 0, 1); // Blue for temp basals
      //    let duration = t.duration * 60 * 1000;
      //    let end = start + duration;
      //    let startX = graphX + Math.round(graphW * (start - twoHoursAgo) / (2 * 60 * 60 * 1000));
      //    let endX = graphX + Math.round(graphW * (end - twoHoursAgo) / (2 * 60 * 60 * 1000));
      //    let rate = t.absolute;
      //    let barY = y + h - ((rate / 3.0) * (h / 2)); // Scale against max 3.0 U/hr
      //    if (startX < graphX + graphW && endX > graphX) {
      //        g.fillRect(Math.max(graphX, startX), barY, Math.min(graphX + graphW, endX), y + h);
      //    }
      //}
      if (t.insulin) {
          g.setColor(0,0.5,0.5);
          let bolusX = graphX + graphW * (start - twoHoursAgo) / (2 * 60 * 60 * 1000);
          let radius = Math.max(2, t.insulin * 1.5);
          if (bolusX > graphX && bolusX < graphX + graphW){
               g.fillCircle(bolusX, y + radius + 1, radius);
          }
      }
  });
}

// === INITIAL SETUP ===
function start() {
  Bangle.setUI("clock");
  Bangle.loadWidgets();

  // 1. Load everything once at the start
  updateCurrentData();
  assembleHistoryAndDraw(); // This populates the screen the first time

  // 2. Set up a FAST timer for the lightweight data
  setInterval(updateCurrentData, 5000); // Check for new BG/Status every 5s

  // 3. Set up a SLOW timer for the heavyweight history data
  setInterval(assembleHistoryAndDraw, 5 * 60 * 1000); // Re-assemble history every 5 minutes

  // 4. Also update the lightweight data when the screen turns on
  Bangle.on('lcdPower', (on) => {
    if (on) {
      updateCurrentData(); // Just a quick update, not the full history
      draw(); // Redraw immediately with current data
    }
  });

  // Initial draw is handled by the first call to assembleHistoryAndDraw()
}

// Run the setup
start();

