const lib = require('aaps-lib.js');

// === GLOBAL DATA and CONSTANTS
// ===================================================================================
const MGDL_TO_MMOL = 18.0182;
const HIGH_MMOL = 10.0;
const LOW_MMOL = 4.0;
const H = g.getHeight();
const W = g.getWidth();
let drawTimeout;

// === GLOBAL DATA and CONSTANTS ===
let currentStatusData = { sgv: "---", delta: "---", trend: "FLAT", iob: "---", cob: "---", ts: 0 };
let historyData = { glucose: [], treatments: [], basals: [] };
let clockInterval; // To keep track of the main clock timer
let settings;
let tapTimeout; // to track the tap timer for double-taps

// === DATA HANDLING AND DRAWING ===

// ** OPTIMIZED: This function ONLY reads the lightweight files. **
function updateCurrentData() {
  let needsRedraw = false;

  const statusFile = require("Storage").readJSON("aaps_status.json", 1);
  if (statusFile && statusFile.ts > currentStatusData.ts) {
    currentStatusData = statusFile;
    needsRedraw = true;
  }

  // We only redraw if something new was loaded and the screen is on.
  if (needsRedraw && Bangle.isLCDOn()) {
    draw();
  }
}

// This is the HEAVY function that ONLY runs when needed.
function assembleHistoryAndDraw() {
  console.log("Assembling full history...");
  const metaFile = require("Storage").readJSON("aaps_h_meta.json", 1);
  if (metaFile) {
    let assembledGlucose = [];
    for (let i = 0; i < metaFile.glucoseChunks; i++) {
      let chunkFile = require("Storage").readJSON(`aaps_h_gl_${i}.json`, 1);
      if (chunkFile && chunkFile.glucose) {
        assembledGlucose = assembledGlucose.concat(chunkFile.glucose);
      }
    }
    historyData.glucose = assembledGlucose;

    console.log('loading treatments from file...');
    let assembledTreatments = [];
    for (let i = 0; i < metaFile.treatmentChunks; i++) {
      let chunkFile = require("Storage").readJSON(`aaps_h_tr_${i}.json`, 1);
      console.log(`loading treatments from file: ${i}`);
      if (chunkFile && chunkFile.treatments) {
          assembledTreatments = assembledTreatments.concat(chunkFile.treatments);
          console.log(`loading treatments from file: concatenating treatments: ${chunkFile.treatments}`);
      }
    }
    historyData.treatments = assembledTreatments;
    console.log('done loading treatments from file.');

    //const sortByTimestamp = (a, b) => a.ts - b.ts;
    //.sort(sortByTimestamp);
    // historyData.treatments = ...
  }

  // Read the new basal history file
  let basalFile = require("Storage").readJSON("aaps_basal.json", 1);
  if (basalFile && basalFile.basals) {
    historyData.basals = basalFile.basals;
  }


  // After the heavy lifting is done, trigger a final redraw.
  if (Bangle.isLCDOn()) {
    draw();
  }
  console.log("Full history assembling done.");
}

// === MASTER DRAW FUNCTION ===
// This function is now very fast because it doesn't read any files.
function draw() {
  // --- This is the new, reliable way to keep the time updated ---
  if (clockInterval) clearInterval(clockInterval);
  clockInterval = setTimeout(() => {
    if (Bangle.isLCDOn()) draw();
  }, 60000 - (Date.now() % 60000));
  // ---

  g.reset();
  g.clear();
  Bangle.loadWidgets();
  Bangle.drawWidgets();

  const leftCol = { x: 0, y: 24, w: 72, h: H - 24 };
  const topRight = { x: leftCol.w + 1, y: 24, w: W - leftCol.w - 1, h: 80 };
  const bottomRight = { x: leftCol.w + 1, y: topRight.y + topRight.h, w: W - leftCol.w - 1, h: H - topRight.y - topRight.h };

  drawLeftColumn(leftCol.x, leftCol.y, leftCol.w, leftCol.h);
  drawTopRight(topRight.x, topRight.y, topRight.w, topRight.h);
  drawBottomRightGraph(bottomRight.x, bottomRight.y, bottomRight.w, bottomRight.h);
}

function drawLeftColumn(x, y, w, h) {
  let glucoseMmol = null, deltaMmol = null;
  let textColor = "#000";

  glucoseMmol = currentStatusData.sgv / MGDL_TO_MMOL;

  if (glucoseMmol >= HIGH_MMOL || glucoseMmol <= LOW_MMOL) textColor = "#F00"; // Red if out of range

  const sgvText = currentStatusData.sgv ? glucoseMmol.toFixed(1) : "---";
  const mainBgX = x + w / 2;
  const mainBgY = y + 20;

  // --- Calculate the age of the reading ---
  let minutesAgo = 100; // Default if no data
  // Check if we have a valid timestamp
  if (currentStatusData.ts > 0) {
    // Difference in milliseconds
    let timeDiff = Date.now() - currentStatusData.ts;
    // Convert to minutes and round to the nearest whole number
    minutesAgo = Math.round(timeDiff / 60000);
  }

  if (minutesAgo > 5) {
    let textColor = "#999";
  }
  
  g.setFontAlign(0, 0);
  g.setColor(textColor).setFont("Vector", 32).drawString(sgvText, mainBgX, mainBgY);
  
  if (minutesAgo > 1) {
    // Get the width of the BG text to position the superscript correctly
    const sgvTextWidth = g.stringWidth(currentStatusData.sgv);
    
    // Calculate position: to the right of the main text, and raised up
    const superscriptX = mainBgX + (sgvTextWidth / 2) + 3; // 3px gap
    const superscriptY = mainBgY - 10; // 10px higher than the main text's center

    g.setFontAlign(-1, 0); // Left-align the superscript
    g.setFont("Vector", 12); // Use a small but readable font
    g.drawString(`(${minutesAgo})`, superscriptX, superscriptY);
  }
  
  g.setColor("#000"); 
  deltaMmol = (Math.round(10*(currentStatusData.delta / MGDL_TO_MMOL))/10).toString();
  if (deltaMmol[0] != '-') {
    deltaMmol = "+"+deltaMmol;
  }
  if (!deltaMmol.includes(".")) {
    deltaMmol = deltaMmol+".0";
  }
  g.setFont("Vector", 16).drawString(deltaMmol, x + w/2 - 10, y + 48);
  drawTrendArrow(x + w/2 + 25, y + 48, currentStatusData.trend);

  let basal = (currentStatusData.basal != null)?currentStatusData.basal:"---";

  g.setFont("Vector", 14).setFontAlign(0, 0);
  g.drawString("BAS: "+basal, x + w/2, y + h - 48);
  g.drawString("COB: "+Math.round(currentStatusData.cob).toString(), x + w/2, y + h - 32);
  g.drawString("IOB: "+currentStatusData.iob.toString(), x + w/2, y + h - 16);
  
  g.setColor("#F00"); // Red separator line
  g.fillRect(x + w -1, y, x + w, y + h);
}

function drawTrendArrow(x, y, type) {
  g.setColor("#000");
  const ARROW_SIZE = 8;
  const T = 2; // shaft thickness

  if (!type) return;
  switch (type) {
    case "FLAT":
      // head
      g.fillPoly([x-ARROW_SIZE,y, x,y-ARROW_SIZE/2, x,y+ARROW_SIZE/2, x-ARROW_SIZE,y]);
      // shaft
      g.fillRect(x-ARROW_SIZE, y - T/2, x, y + T/2);
      break;

    case "UP":
      // head (tip at y-ARROW_SIZE)
      g.fillPoly([x, y-ARROW_SIZE, x-ARROW_SIZE/2, y, x+ARROW_SIZE/2, y, x, y-ARROW_SIZE]);
      // shaft (from base up to head)
      g.fillRect(x - T/2, y-ARROW_SIZE, x + T/2, y);
      break;

    case "DOWN":
      // head (tip at y+ARROW_SIZE)
      g.fillPoly([x, y+ARROW_SIZE, x-ARROW_SIZE/2, y, x+ARROW_SIZE/2, y, x, y+ARROW_SIZE]);
      // shaft (from base down to head)
      g.fillRect(x - T/2, y, x + T/2, y+ARROW_SIZE);
      break;

    case "FORTY_FIVE_UP":
      // shaft: slim parallelogram along SW -> NE
      g.fillPoly([
        x-ARROW_SIZE,   y+ARROW_SIZE - T,   // tail low
        x-ARROW_SIZE+T, y+ARROW_SIZE,       // tail high
        x+ARROW_SIZE,   y-ARROW_SIZE + T,   // near tip high
        x+ARROW_SIZE-T, y-ARROW_SIZE        // near tip low
      ]);

      // head: small right-isosceles triangle at tip
      g.fillPoly([
        x+ARROW_SIZE,   y-ARROW_SIZE,       // tip
        x+ARROW_SIZE-4, y-ARROW_SIZE,       // base left
        x+ARROW_SIZE,   y-ARROW_SIZE+4      // base down
      ]);
      break;

    case "FORTY_FIVE_DOWN":
      // shaft: slim parallelogram along NW -> SE
      g.fillPoly([
        x-ARROW_SIZE,   y-ARROW_SIZE + T,   // tail high
        x-ARROW_SIZE+T, y-ARROW_SIZE,       // tail low
        x+ARROW_SIZE,   y+ARROW_SIZE - T,   // near tip low
        x+ARROW_SIZE-T, y+ARROW_SIZE        // near tip high
      ]);

      // head: small right-isosceles triangle at tip
      g.fillPoly([
        x+ARROW_SIZE,   y+ARROW_SIZE,       // tip
        x+ARROW_SIZE-4, y+ARROW_SIZE,       // base left
        x+ARROW_SIZE,   y+ARROW_SIZE-4      // base up
      ]);
      break;

    default: ;
  }
}

function drawTopRight(x, y, w, h) {
  g.setColor(0,0,0);
  const d = new Date();
  const timeYPos = y + 2;
  let hStr = ("0"+d.getHours()).substr(-2), mStr = ("0"+d.getMinutes()).substr(-2);
  g.setFont("Vector", 42); 
  const hWidth = g.stringWidth(hStr);
  g.setFont("Vector", 30);
  const mWidth = g.stringWidth(mStr);
  const gap = 2, totalWidth = hWidth + gap + mWidth, horizontalShift = 4;
  let currentX = x + (w - totalWidth) / 2 + horizontalShift;
  g.setFont("Vector", 42).setFontAlign(-1, -1);
  g.drawString(hStr, currentX, timeYPos);
  currentX += hWidth + gap;
  g.setFont("Vector", 30).setFontAlign(-1, -1); 
  g.drawString(mStr, currentX, timeYPos);
  const dateYPos = timeYPos + 46;
  const locale = require("locale");
  const day = locale.dow(d, 1).toUpperCase(), date = d.getDate(), month = locale.month(d, 1).toUpperCase();
  g.setFont("Vector", 15).setFontAlign(0, 0);
  g.drawString(`${day} ${date} ${month}`, x + w/2, dateYPos);
}

function drawBottomRightGraph(x, y, w, h) {
  const margin = 5;
  const graphX = x + margin;
  const graphW = w - (margin * 2);
  const MIN_MMOL_SCALE = 2.0;
  const MAX_MMOL_SCALE = 14.0;
  let threshColor = g.getBgColor() == "#ffffff" ? [0.8,0,0] : [0,0,0];
  g.setColor.apply(g, threshColor);
  let highY = y + h - (((HIGH_MMOL - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
  let lowY = y + h - (((LOW_MMOL - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
  g.drawLine(graphX, highY, graphX + graphW, highY);
  g.drawLine(graphX, lowY, graphX + graphW, lowY);

  let now = new Date().getTime();
  let ninetyMinutesMillis = (90 * 60 * 1000);
  let graphStartTime = now - ninetyMinutesMillis;


  // 1. basals in the bottom
  var lastVerticalBarX = 0;
  var lastY = y + h;
  const MAX_BASAL_AS_MMOL = 8;
  if (historyData.basals.length > 0) {
    var maxBasal = 0.0;
    for (let i = 0; i < historyData.basals.length; i++) {
      if (historyData.basals[i].rate > maxBasal) {
          maxBasal = historyData.basals[i].rate;
      }
    }
    for (let i = 0; i < historyData.basals.length; i++) {
      let currentPoint = historyData.basals[i];
      // Determine the end time for this segment (it's the start time of the next point, or 'now')
      let nextPoint = (i + 1 < historyData.basals.length) ? historyData.basals[i+1] : { ts: Date.now() };

      // Calculate the start and end X coordinates using the same time scale as the BG plot.
      let startX = graphX + graphW * (currentPoint.ts - graphStartTime) / (2 * 60 * 60 * 1000);
      if (startX < graphX) {
        continue;
      }
      let endX = graphX + graphW * (nextPoint.ts - graphStartTime) / (2 * 60 * 60 * 1000);
      if (endX > graphX+graphW) {
        let zeroY = y + h;
        g.drawLine(endX, lastY, endX, zeroY);
        break;
      }

      // Convert the basal rate (e.g., 0.8 U/hr) to its equivalent position on the mmol graph.
      let equivalentMmol = (currentPoint.rate / maxBasal) * MAX_BASAL_AS_MMOL;

      // Calculate the Y coordinate for the top of the bar using the same Y scale as the BG plot.
      let barY = y + h - (((equivalentMmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);

      // Ensure we don't draw outside the graph area
      startX = Math.max(graphX, startX);
      endX = Math.min(graphX + graphW, endX);

      g.setColor("#00FFFF"); // Internal fill color.
      g.fillRect(startX, barY, endX, y + h);
      g.setColor("#0000FF"); // Blue for basal
      g.drawLine(startX, barY, endX, barY);

      if (lastVerticalBarX < startX) {
        // there was no vertical bar in the beginning of this basal.
        g.drawLine(startX, lastY, startX, barY);
      }

      if (i + 1 < historyData.basals.length) {
        // Y value for the next entry.
        let nextPointBarY = y + h - ((((nextPoint.rate/ maxBasal) * MAX_BASAL_AS_MMOL - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
        g.drawLine(endX, barY, endX, nextPointBarY);
        lastVerticalBarX = endX;
      }
      else {
        let zeroY = y + h;
        g.drawLine(endX, barY, endX, zeroY);
      }

      lastY = barY;
    }
  }
  
  // 2. treatments in the middle
  
  historyData.treatments.forEach(t => {
      console.log("plotting bolus: "+JSON.stringify(t));
      let start = new Date(t.ts).getTime();
      if (t.insulin) {
          let bolusX = graphX + graphW * (start - graphStartTime) / ninetyMinutesMillis;
          let triangle_half_width = 3;
          //if (bolusX > graphX && bolusX < graphX + graphW){
          //     g.fillCircle(bolusX, y + radius + 1, radius);
          //}
          if (bolusX > graphX && bolusX < graphX + graphW) {

              // 1. Define the 3 vertices of the triangle
              // The triangle will point downwards, with its tip at the bottom.
              const y_top = y + h - 12; // Top top of the triangle
              const y_bottom = y_top + 0.866 * triangle_half_width * 2; // Bottom of the triangle (Pythagoras)

              const vertices = [
                bolusX, y_top,              // Vertex 1: Top tip (at the center X)
                bolusX - triangle_half_width, y_bottom,   // Vertex 2: Top-left corner
                bolusX + triangle_half_width, y_bottom    // Vertex 3: Top-right corner
              ];

              // 2. Draw the filled triangle
              g.setColor("#0000FF");
              g.fillPoly(vertices);
          }
      }
  });
  
  // 3. glucose history on top of all.
  if (historyData.glucose && historyData.glucose.length >= 2) {
    for (let i = 0; i < historyData.glucose.length - 1; i++) {
        let p1 = historyData.glucose[i], p2 = historyData.glucose[i+1];
        if (!p1 || !p2) continue;
        let p1_mmol = p1.sgv / MGDL_TO_MMOL, p2_mmol = p2.sgv / MGDL_TO_MMOL;
        let x1 = graphX + graphW * (new Date(p1.ts).getTime() - graphStartTime) / ninetyMinutesMillis;
        let x2 = graphX + graphW * (new Date(p2.ts).getTime() - graphStartTime) / ninetyMinutesMillis;
        let y1 = y + h - (((p1_mmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
        let y2 = y + h - (((p2_mmol - MIN_MMOL_SCALE) / (MAX_MMOL_SCALE - MIN_MMOL_SCALE)) * h);
        if (x1 >= graphX && x2 <= graphX+graphW) {
          if (p1_mmol < LOW_MMOL && p2_mmol < LOW_MMOL) {
            g.setColor("#FF0000");
          }
          else if (p1_mmol  > HIGH_MMOL && p2_mmol  > HIGH_MMOL) {
            g.setColor("#FF0000");
          }
          else {
             g.setColor("#00FF00");
          }
          g.drawLine(x1, y1, x2, y2);
          g.drawLine(x1, y1+1, x2, y2+1);
          g.drawLine(x1, y1+2, x2, y2+2);
        }
    }
  }
  
}



// This is the new, complete gesture handling function.
function setupGestures() {
  let drag; // To track swipe events

  Bangle.on('drag', e => {
    // This drag logic is correct and remains the same.
    // It handles all the swipe gestures.
    if (!drag) { 
      drag = { x: e.x, y: e.y, start_y: e.y };
    }
    if (e.b) {
      drag.x = e.x;
      drag.y = e.y;
    }
    if (!e.b) {
      const dx = e.x - drag.x;
      const dy = e.y - drag.y;
      const startY = drag.start_y;
      drag = undefined;

      const SWIPE_THRESHOLD = 40;
      
      if (Math.abs(dx) > Math.abs(dy) + 10) { // Horizontal
        if (dx > SWIPE_THRESHOLD && settings.swipeRight) Bangle.load(settings.swipeRight + ".app.js");
        else if (dx < -SWIPE_THRESHOLD && settings.swipeLeft) Bangle.load(settings.swipeLeft + ".app.js");
      } else { // Vertical
        if (dy > SWIPE_THRESHOLD && settings.swipeDown) Bangle.load(settings.swipeDown + ".app.js");
        else if (dy < -SWIPE_THRESHOLD) {
          if (settings.swipeUp) {
             Bangle.load(settings.swipeUp + ".app.js");
          }
        }
      }
    }
  });

  // --- THIS IS THE NEW DOUBLE-CLICK LOGIC ---
  Bangle.on('touch', () => {
    // If a drag is in progress, ignore the touch event.
    if (drag) return;

    if (tapTimeout) {
      // If a timer is already running, this is the SECOND tap.
      // It's a double-click!
      clearTimeout(tapTimeout); // Cancel the single-click timer
      tapTimeout = undefined;
      
      console.log("Double-click detected, launching Settings.");
      // The settings for a Bangle.js app are typically named 'app.settings.js'
      Bangle.load("aaps.settings.js"); 

    } else {
      // This is the FIRST tap.
      // Start a timer. If it finishes, it's a single-click.
      tapTimeout = setTimeout(() => {
        tapTimeout = undefined;
        console.log("Single-click detected, launching AAPS Menu.");
        Bangle.load("aaps-menu.app.js");
      }, 300); // 300ms is a good timeout for double-clicks
    }
  });
}

function loadSettings() {
  // Load settings from the file, providing safe defaults if the file doesn't exist
  settings = require('Storage').readJSON('aaps.settings.json', 1) || {
    swipeUp: 'aaps-menu',
    swipeDown: 'messages',
    swipeLeft: '',
    swipeRight: '',
    swipeBottomUp: '',
  };
}

// === INITIAL SETUP ===
function start() {
  Bangle.setUI("clock");
  Bangle.loadWidgets();

  // Load settings from the file first
  loadSettings();

  lib.sendCommand("RequestInitialData", {});
  // 1. Load everything once at the start
  updateCurrentData();
  assembleHistoryAndDraw(); // This populates the screen the first time

  // 2. Set up a FAST timer for the lightweight data
  setInterval(updateCurrentData, 5000); // Check for new BG/Status every 5s

  // 3. Set up a SLOW timer for the heavyweight history data
  setInterval(assembleHistoryAndDraw, 5 * 60 * 1000); // Re-assemble history every 5 minutes

  // Call the function to enable all our gestures
  setupGestures();

  // 4. Also update the lightweight data when the screen turns on
  Bangle.on('lcdPower', (on) => {
    if (on) {
      updateCurrentData(); // Just a quick update, not the full history
      draw(); // Redraw immediately with current data
    }
  });

  // Initial draw is handled by the first call to assembleHistoryAndDraw()
}

// Run the setup
start();

